_InitMain:
  begin   (midx: 0)
//TestServo.c,4 :: 		void InitMain() {
_InitMain:
  begin   (midx: 0)
//TestServo.c,5 :: 		GPIO_Digital_Input (&GPIOA_BASE, _GPIO_PINMASK_3 | _GPIO_PINMASK_4 | _GPIO_PINMASK_5 | _GPIO_PINMASK_6); // configure PORTA pins as input
	R1 <4> <- 120   (midx: 0)
	R0 <4> <- #GPIOA_BASE   (midx: 0)
	CALL _GPIO_Digital_Input   (midx: 0)
  end
   (midx: 0)
_main:
  begin   (midx: 0)
//TestServo.c,8 :: 		void main() {
_main:
  begin   (midx: 0)
//TestServo.c,9 :: 		InitMain();
	CALL _InitMain   (midx: 0)
//TestServo.c,10 :: 		current_duty  = 100;                        // initial value for current_duty
	R1 <2> <- 100   (midx: 0)
	R0 <4> <- addr(_current_duty)   (midx: 0)
	FLOC_main+0 <4> <- R0   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//TestServo.c,11 :: 		current_duty1 = 100;                        // initial value for current_duty1
	R1 <2> <- 100   (midx: 0)
	R0 <4> <- addr(_current_duty1)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//TestServo.c,13 :: 		pwm_period1 = PWM_TIM1_Init(5000);
	R0 <4> <- 5000   (midx: 0)
	CALL _PWM_TIM1_Init   (midx: 0)
	R1 <4> <- addr(_pwm_period1)   (midx: 0)
	[R1] <2> <- R0   (midx: 0)
//TestServo.c,14 :: 		pwm_period2 = PWM_TIM4_Init(5000);
	R0 <4> <- 5000   (midx: 0)
	CALL _PWM_TIM4_Init   (midx: 0)
	R1 <4> <- addr(_pwm_period2)   (midx: 0)
	[R1] <2> <- R0   (midx: 0)
//TestServo.c,16 :: 		PWM_TIM1_Set_Duty(current_duty,  _PWM_NON_INVERTED, _PWM_CHANNEL1);  // Set current duty for PWM_TIM1
	R0 <4> <- FLOC_main+0   (midx: 0)
	R0 <4> <- R0   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R2 <1> <- 0   (midx: 0)
	R1 <1> <- 0   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _PWM_TIM1_Set_Duty   (midx: 0)
//TestServo.c,17 :: 		PWM_TIM4_Set_Duty(current_duty1, _PWM_NON_INVERTED, _PWM_CHANNEL2);  // Set current duty for PWM_TIM4
	R0 <4> <- addr(_current_duty1)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R2 <1> <- 1   (midx: 0)
	R1 <1> <- 0   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _PWM_TIM4_Set_Duty   (midx: 0)
//TestServo.c,19 :: 		PWM_TIM1_Start(_PWM_CHANNEL1, &_GPIO_MODULE_TIM1_CH1_PE9);
	R1 <4> <- #__GPIO_MODULE_TIM1_CH1_PE9   (midx: 0)
	R0 <1> <- 0   (midx: 0)
	CALL _PWM_TIM1_Start   (midx: 0)
//TestServo.c,20 :: 		PWM_TIM4_Start(_PWM_CHANNEL2, &_GPIO_MODULE_TIM4_CH2_PD13);
	R1 <4> <- #__GPIO_MODULE_TIM4_CH2_PD13   (midx: 0)
	R0 <1> <- 1   (midx: 0)
	CALL _PWM_TIM4_Start   (midx: 0)
//TestServo.c,22 :: 		while (1) {                                // endless loop
0:   (midx: 0)
//TestServo.c,23 :: 		if (GPIOA_IDR.B3) {                // button on RA3 pressed
	R1 <4> <- addr(GPIOA_IDR)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (!R0) then goto 2   (midx: 0)
//TestServo.c,24 :: 		Delay_ms(1);
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 2)
	asm: -1   (midx: 1)
	asm: -1   (midx: 5)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
//TestServo.c,25 :: 		current_duty = current_duty + 5;       // increment current_duty
	R2 <4> <- addr(_current_duty)   (midx: 0)
	R0 <2> <- [R2]   (midx: 0)
	R1 <2> <-  R0 + 5   (midx: 1)
	[R2] <2> <- R1   (midx: 0)
//TestServo.c,26 :: 		if (current_duty > pwm_period1) {      // if we increase current_duty greater then possible pwm_period1 value
	R0 <4> <- addr(_pwm_period1)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	if ( R1 <= R0) then goto 4   (midx: 1)
//TestServo.c,27 :: 		current_duty = 0;                    // reset current_duty value to zero
	R1 <2> <- 0   (midx: 0)
	R0 <4> <- addr(_current_duty)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//TestServo.c,28 :: 		}
4:   (midx: 0)
//TestServo.c,29 :: 		PWM_TIM1_Set_Duty(current_duty,  _PWM_NON_INVERTED, _PWM_CHANNEL1); // set newly acquired duty ratio
	R0 <4> <- addr(_current_duty)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R2 <1> <- 0   (midx: 0)
	R1 <1> <- 0   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _PWM_TIM1_Set_Duty   (midx: 0)
//TestServo.c,30 :: 		}
2:   (midx: 0)
//TestServo.c,32 :: 		if (GPIOA_IDR.B4) {                // button on RA4 pressed
	R1 <4> <- addr(GPIOA_IDR)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (!R0) then goto 5   (midx: 0)
//TestServo.c,33 :: 		Delay_ms(1);
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 2)
	asm: -1   (midx: 1)
	asm: -1   (midx: 5)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
//TestServo.c,34 :: 		current_duty = current_duty - 5;       // decrement current_duty
	R2 <4> <- addr(_current_duty)   (midx: 0)
	R0 <2> <- [R2]   (midx: 0)
	R1 <2> <-  R0 - 5   (midx: 1)
	[R2] <2> <- R1   (midx: 0)
//TestServo.c,35 :: 		if (current_duty > pwm_period1) {      // if we decrease current_duty greater then possible pwm_period1 value (overflow)
	R0 <4> <- addr(_pwm_period1)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	if ( R1 <= R0) then goto 7   (midx: 1)
//TestServo.c,36 :: 		current_duty = pwm_period1;          // set current_duty to max possible value
	R0 <4> <- addr(_pwm_period1)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(_current_duty)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//TestServo.c,37 :: 		}
7:   (midx: 0)
//TestServo.c,38 :: 		PWM_TIM1_Set_Duty(current_duty,  _PWM_NON_INVERTED, _PWM_CHANNEL1); // set newly acquired duty ratio
	R0 <4> <- addr(_current_duty)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R2 <1> <- 0   (midx: 0)
	R1 <1> <- 0   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _PWM_TIM1_Set_Duty   (midx: 0)
//TestServo.c,39 :: 		}
5:   (midx: 0)
//TestServo.c,41 :: 		if (GPIOA_IDR.B5) {                // button on RA5 pressed
	R1 <4> <- addr(GPIOA_IDR)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (!R0) then goto 8   (midx: 0)
//TestServo.c,42 :: 		Delay_ms(1);
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 2)
	asm: -1   (midx: 1)
	asm: -1   (midx: 5)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
//TestServo.c,43 :: 		current_duty1 = current_duty1 + 5;     // increment current_duty
	R2 <4> <- addr(_current_duty1)   (midx: 0)
	R0 <2> <- [R2]   (midx: 0)
	R1 <2> <-  R0 + 5   (midx: 1)
	[R2] <2> <- R1   (midx: 0)
//TestServo.c,44 :: 		if (current_duty1 > pwm_period2) {     // if we increase current_duty1 greater then possible pwm_period2 value
	R0 <4> <- addr(_pwm_period2)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	if ( R1 <= R0) then goto 10   (midx: 1)
//TestServo.c,45 :: 		current_duty1 = 0;                   // reset current_duty1 value to zero
	R1 <2> <- 0   (midx: 0)
	R0 <4> <- addr(_current_duty1)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//TestServo.c,46 :: 		}
10:   (midx: 0)
//TestServo.c,47 :: 		PWM_TIM4_Set_Duty(current_duty1, _PWM_NON_INVERTED, _PWM_CHANNEL2);       // set newly acquired duty ratio
	R0 <4> <- addr(_current_duty1)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R2 <1> <- 1   (midx: 0)
	R1 <1> <- 0   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _PWM_TIM4_Set_Duty   (midx: 0)
//TestServo.c,48 :: 		}
8:   (midx: 0)
//TestServo.c,50 :: 		if (GPIOA_IDR.B6) {                // button on RA6 pressed
	R1 <4> <- addr(GPIOA_IDR)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (!R0) then goto 11   (midx: 0)
//TestServo.c,51 :: 		Delay_ms(1);
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 2)
	asm: -1   (midx: 1)
	asm: -1   (midx: 5)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
//TestServo.c,52 :: 		current_duty1 = current_duty1 - 5;     // decrement current_duty
	R2 <4> <- addr(_current_duty1)   (midx: 0)
	R0 <2> <- [R2]   (midx: 0)
	R1 <2> <-  R0 - 5   (midx: 1)
	[R2] <2> <- R1   (midx: 0)
//TestServo.c,53 :: 		if (current_duty1 > pwm_period2) {     // if we decrease current_duty1 greater then possible pwm_period1 value (overflow)
	R0 <4> <- addr(_pwm_period2)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	if ( R1 <= R0) then goto 13   (midx: 1)
//TestServo.c,54 :: 		current_duty1 = pwm_period2;         // set current_duty to max possible value
	R0 <4> <- addr(_pwm_period2)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(_current_duty1)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//TestServo.c,55 :: 		}
13:   (midx: 0)
//TestServo.c,56 :: 		PWM_TIM4_Set_Duty(current_duty1, _PWM_NON_INVERTED, _PWM_CHANNEL2);
	R0 <4> <- addr(_current_duty1)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R2 <1> <- 1   (midx: 0)
	R1 <1> <- 0   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _PWM_TIM4_Set_Duty   (midx: 0)
//TestServo.c,57 :: 		}
11:   (midx: 0)
//TestServo.c,59 :: 		Delay_ms(1);                             // slow down change pace a little
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 2)
	asm: -1   (midx: 1)
	asm: -1   (midx: 5)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
//TestServo.c,60 :: 		}
	goto	0   (midx: 0)
  end
   (midx: 0)
